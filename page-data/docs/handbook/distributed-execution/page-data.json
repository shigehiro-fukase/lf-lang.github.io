{
    "componentChunkName": "component---src-templates-documentation-tsx",
    "path": "/docs/handbook/distributed-execution",
    "result": {"data":{"markdownRemark":{"id":"2c75a717-1752-5c95-a03e-3a87114a64ab","excerpt":"Federated execution is not supported in $target-language$. NOTE: This describes a highly preliminary capability to map pieces of a Lingua Franca program to…","html":"<div class=\"lf-cpp lf-rs\">\n<p><strong>Federated execution is not supported in $target-language$.</strong></p>\n</div>\n<div class=\"lf-c lf-py lf-ts\">\n<div class=\"gatsby-highlight\" data-language=\"diff\"><pre class=\"language-diff\"><code class=\"language-diff\"><span class=\"token diff bold\"><span class=\"token prefix diff\">!</span> The information in this page is outdated, and will be updated soon.</span></code></pre></div>\n<p><strong>NOTE:</strong> This describes a highly preliminary capability to map pieces of a Lingua Franca program to different machines. This capability is very much under development. This capability has been tested on MacOS and Linux, but not yet on Windows. Volunteer to do that and update these instructions?</p>\n<p>A Lingua Franca program can be separated into separate programs called <strong>federates</strong> that communicate with one another. The federates will execute in separate processes and even on separate machines. They can be distributed across networks and can even be written in different target languages.</p>\n<p>There is always one federate named <strong>RTI</strong>, for <strong>runtime infrastructure</strong> that coordinates startup and shutdown and may, if the implementation is centralized, mediate communication. The RTI needs to be compiled and installed separately on the system before any federation can execute. The instruction on how to do so can be found <a href=\"https://github.com/lf-lang/lingua-franca/blob/master/org.lflang/src/lib/core/federated/RTI/README.md\">here</a>.</p>\n<p>Other than the RTI, if there are <em>n</em> federates, then the code generator will generate <em>n</em> separate programs with names of the form <em>Name_Federate</em>, where <em>Name</em> is the name of the top-level Lingua Franca file (without the .lf extension) and <em>Federate</em> is the name of the federate reactor. The code generator also produces a shell script that lauches all the federates and the RTI and a second shell script that distributes the generated code for the federates (not the RTI) to the specified machines and compiles the code on that machine.</p>\n<h2 id=\"minimal-example\" style=\"position:relative;\"><a href=\"#minimal-example\" aria-label=\"minimal example permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Minimal Example</h2>\n<p>A minimal federated execution is specified by using the <strong>federated</strong> keyword instead of <strong>main</strong> for the main federate. An example is given in <a href=\"https://github.com/lf-lang/lingua-franca/blob/master/example/C/Federated/HelloWorld/HelloWorld.lf\">example/C/Federated/HelloWorld/HelloWorld.lf</a>, which looks like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">target C;\nreactor MessageGenerator { ... }\nreactor PrintMessage { ... }\n\nfederated reactor DistributedHelloWorld {\n    source = new MessageGenerator();\n    print = new PrintMessage();\n    source.message -> print.message;\n}</code></pre></div>\n<p>The <strong>federated</strong> keyword tells the code generator that the program is to be split into several distinct programs, one for each top level reactor. When you run the code generator on <a href=\"https://github.com/lf-lang/lingua-franca/blob/master/example/C/Federated/HelloWorld/HelloWorld.lf\">example/C/Federated/HelloWorld/HelloWorld.lf</a>, the following three programs will appear in the <code class=\"language-text\">bin</code> directory:</p>\n<ul>\n<li>HelloWorld</li>\n<li>HelloWorld_source</li>\n<li>HelloWorld_print</li>\n</ul>\n<p>The root name, <em>HelloWorld</em>, is the name of the .lf file from which these are generated. The suffixes “_source” and “_print” come from the names of the top-level instances. There will always be one federate for each top-level reactor instance.</p>\n<p>To run the program, you can simply run <code class=\"language-text\">bin/HelloWorld</code>, which is a <code class=\"language-text\">bash</code> script that launches the other three programs. Alternatively, you can manually execute the RTI and the federate programs by starting them on the command line in any order.</p>\n<p>In addition, one more <code class=\"language-text\">bash</code> shell scripts may be generated:</p>\n<ul>\n<li>HelloWorld_distribute.sh</li>\n</ul>\n<p>This script is generated if any of the two federates, or the RTI are specified to be run on a remote machine (see below for how to do that). This script will copy the source files for the relevant program (but not the RTI) to the remote machine and compile them there. The RTI needs to be separately installed on the remote machine.</p>\n<h2 id=\"coordinated-start\" style=\"position:relative;\"><a href=\"#coordinated-start\" aria-label=\"coordinated start permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Coordinated Start</h2>\n<p>When the above programs execute, each federate registers with the RTI. When all expected federates have registered, the RTI broadcasts to the federates the logical time at which they should start execution. Hence, all federates start at the same logical time.</p>\n<p>The starting logical time is determined as follows. When each federate starts executing, it sends its current physical time (drawn from its real-time clock) to the RTI. When the RTI has heard from all the federates, it chooses the largest of these physical times, adds a fixed offset (currently one second), and broadcasts the resulting time to each federate.</p>\n<p>When a federate receives the starting time from the RTI, if it is running in realtime mode (the default), then it will wait until its local physical clock matches or exceeds that starting time. Thus, to the extent that the machines have <a href=\"#clock-synchronization\">synchronized clocks</a>, the federates will all start executing at roughly the same physical time, a physical time close to the starting logical time.</p>\n<h2 id=\"coordinated-shutdown\" style=\"position:relative;\"><a href=\"#coordinated-shutdown\" aria-label=\"coordinated shutdown permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Coordinated Shutdown</h2>\n<p>Coordinating the shutdown of a distributed program is discussed in [[Termination]].</p>\n<h2 id=\"communication-between-federates\" style=\"position:relative;\"><a href=\"#communication-between-federates\" aria-label=\"communication between federates permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Communication Between Federates</h2>\n<p>When one federate sends data to another, by default, the timestamp at the receiver will match the timestamp at the sender. You can also specify a logical delay on the communication using the <strong>after</strong> keyword. For example, if we had instead specified</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">\tsource.out -> print.in after 200 msec;</code></pre></div>\n<p>then the timestamp at the receiving end will be incremented by 200 msec compared to the timestamp at the sender (see <a href=\"https://github.com/lf-lang/lingua-franca/blob/master/example/C/Federated/HelloWorld/HelloWorldAfter.lf\">example/C/Federated/HelloWorld/HelloWorldAfter.lf</a>).</p>\n<p>The preservation of timestamps across federates implies some constraints (see <a href=\"#physical-connections\">physical connections</a> below for a way to avoid these constraints). How these constraints are managed depends on whether you choose <strong>centralized</strong> or <strong>decentralized</strong> coordination.</p>\n<h2 id=\"containerized-execution\" style=\"position:relative;\"><a href=\"#containerized-execution\" aria-label=\"containerized execution permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Containerized Execution</h2>\n<p>FIXME: Point to /docs/handbook/containerized-execution</p>\n<p>FIXME: <a href=\"https://github.com/lf-lang/lingua-franca/blob/master/test/C/src/docker/federated/DistributedCountContainerized.lf\">Here</a> is an test that imports an <a href=\"https://github.com/lf-lang/lingua-franca/blob/master/test/C/src/federated/DistributedCount.lf\">existing</a> federated test with the addition of a docker: true flag in the target property of the test. This test will automatically run in multiple Docker containers (one for the RTI and one for each federate) in our CI.</p>\n<h2 id=\"centralized-coordination\" style=\"position:relative;\"><a href=\"#centralized-coordination\" aria-label=\"centralized coordination permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Centralized Coordination</h2>\n<p>In the <strong>centralized</strong> mode of coordination (the default), the RTI regulates the advancement of time in each of the federates in order to ensure that the logical time semantics of Lingua Franca is respected. If the <code class=\"language-text\">print</code> federate has an event with timestamp <em>t</em> that it wants to react to (it is the earliest event in its event queue or it is a <strong>physical action</strong> that just triggered), then it needs to get the OK from the RTI to advance its logical time to <em>t</em>. The RTI grants this time advance only when it can assure that <code class=\"language-text\">print</code> has received all messages that it will ever receive with timestamps <em>t</em> or less.</p>\n<p>First, note that, by default, logical time on each federate never advances ahead of physical time, as reported by its local physical clock. Consider the consequences for the above connection. Suppose the timestamp of the message sent by <code class=\"language-text\">source</code> is <em>t</em>. This message cannot be sent before the local clock at <code class=\"language-text\">source</code> reaches <em>t</em> and also cannot be sent before the RTI grants to <code class=\"language-text\">source</code> a time advance to <em>t</em>. Since <code class=\"language-text\">source</code> has no federates upstream of it, the RTI will always grant it such a time advance.</p>\n<p>Suppose that the communication latency is <em>L</em>. That is, it takes <em>L</em> time units (in physical time) for a message to traverse the network. Then the <code class=\"language-text\">print</code> federate will not see the message from <code class=\"language-text\">source</code> before physical time <em>t</em> + <em>L</em>, where this physical time is measured by the physical clock on <code class=\"language-text\">source</code>’s host. If that clock differs from the clock on <code class=\"language-text\">print</code>’s host by <em>E</em>, then <code class=\"language-text\">print</code> will see the message at physical time <em>t</em> + <em>E</em> + <em>L</em>, as measured by its own clock. Let the value of the <strong>after</strong> specification (200 msec above) be <em>a</em>. Then the timestamp of the received message is <em>t</em> + <em>a</em>. The relationship between logical and physical times at the receiving end (the <code class=\"language-text\">print</code> federate), therefore, will depend on the relationship between <em>a</em> and <em>E</em> + <em>L</em>. If, for example, <em>E</em> + <em>L</em> > <em>a</em>, then federate <code class=\"language-text\">print</code> will lag behind physical time by at least <em>E</em> + <em>L</em> - <em>a</em>.</p>\n<p>Assume the RTI has granted a time advance to <em>t</em> to federate <code class=\"language-text\">source</code>. Hence, <code class=\"language-text\">source</code> is able to send a message with timestamp <em>t</em>. The RTI now cannot grant any time advance to <code class=\"language-text\">print</code> that is greater than or equal to <em>t</em> + <em>a</em> until the message has been delivered to <code class=\"language-text\">print</code>. In centralized coordination, all messages flow through the RTI, so the RTI will deliver the time advance grant (<strong>TAG</strong>) to <code class=\"language-text\">print</code> only after it has delivered the message.</p>\n<p>If <em>a</em> > <em>E</em> + <em>L</em>, then the existence of this communication does not cause <code class=\"language-text\">print</code>’s logical time to lag behind physical time. This means that if a <strong>physical action</strong> appears at <code class=\"language-text\">print</code>, the RTI will be able to immediately grant a time advance to <code class=\"language-text\">print</code> to the timestamp of that physical action. However, if <em>a</em> &#x3C; <em>E</em> + <em>L</em>, then the RTI will delay granting a time advance to <code class=\"language-text\">print</code> by at least <em>E</em> + <em>L</em> - <em>a</em>. Hence, <em>E</em> + <em>L</em> - <em>a</em> represents an additional latency in the processing of physical actions! This latency could present a problem for meeting deadlines. For this reason, if there are physical actions or deadlines at a federate that receives network messages, it is desirable to set <strong>after</strong> on the connection to that federate to be larger than any expected <em>E</em> + <em>L</em>. This way, there is no additional latency to processing physical actions at this federate and no additional risk of missing deadlines.</p>\n<p>If, in addition, the physical clocks on the hosts are allowed to drift with respect to one another, then <em>E</em> can grow without bound, and hence the lag between logical time and physical time in processing events can grow without bound. This is mitigated either by hosts that themselves realize some clock synchronization algorithm, such as <a href=\"https://en.wikipedia.org/wiki/Network_Time_Protocol\">NTP</a> or <a href=\"https://en.wikipedia.org/wiki/Precision_Time_Protocol\">PTP</a>, or by utilizing Lingua Franca’s own built in <a href=\"#clock-synchronization\">clock synchronization</a>. If the federates lack physical actions and deadlines, however, then unsynchronized clocks present no problem if you are using centralized coordination.</p>\n<p>With centralized coordination, all messages (except those on <a href=\"#physical-connections\">physical connections</a>) go through the RTI. This can create a bottleneck and a single point of failure. To avoid this bottleneck, you can use decentralized coordination.</p>\n<h2 id=\"decentralized-coordination\" style=\"position:relative;\"><a href=\"#decentralized-coordination\" aria-label=\"decentralized coordination permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Decentralized Coordination</h2>\n<p>The default coordination between mechanisms is <strong>centralized</strong>, equivalent to specifying the target property:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">   coordination: centralized</code></pre></div>\n<p>Centralized coordination works as described above, where the advancement of time at each federate is regulated by the RTI. In order for the RTI to be able to safely grant a time advance to a federate, it is also necessary for all messages to that federate to go through the RTI. The RTI, therefore, can easily become a bottleneck.</p>\n<p>An alternative is <strong>decentralized</strong> coordination, which uses a technique called <a href=\"https://ptolemy.berkeley.edu/publications/papers/07/RTAS/\">PTIDES</a>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">   coordination: decentralized</code></pre></div>\n<p>This technique has also been implemented in Google Spanner, a globally distributed database system. In decentralized coordination, each federate has a <strong>safe-to-process</strong> (<strong>STP</strong>) offset. In decentralized coordination, when one federate communicates with another, it does so directly through a dedicated socket without going through the RTI. Moreover, it does not consult the RTI to advance logical time. Instead, it can advance its logical time to <em>t</em> when its physical clock matches or exceeds <em>t</em> + STP.</p>\n<p>By default, the STP is zero. This will work fine under the assumption that <strong>every</strong> logical connection between federates has a sufficiently large <code class=\"language-text\">after</code> clause. That is, the value of the logical delay must exceed the sum of the <a href=\"#clock-synchronization\">clock synchronization</a> error <em>E</em>, the network latency bound <em>L</em>, and the time lag on the sender <em>D</em> (the physical time at which it sends the message minus the timestamp of the message). The sender’s time lag <em>D</em> can be enforced by using a <strong>deadline</strong>. See for example <a href=\"https://github.com/lf-lang/lingua-franca/blob/master/example/C/Federated/HelloWorld/HelloWorldDecentralized.lf\">example/C/Federated/HelloWorld/HelloWorldDecentralized.lf</a>.</p>\n<p>Of course, this assumption can be violated in practice. Analogous to a deadline violation, Lingua Franca provides a mechanism for handling such a violation that is called a <code class=\"language-text\">tardy</code> handlers as done in <a href=\"https://github.com/lf-lang/lingua-franca/blob/master/example/C/Federated/HelloWorld/HelloWorldDecentralized.lf\">example/C/Federated/HelloWorld/HelloWorldDecentralized.lf</a>.(example/C/Federated/HelloWorld/HelloWorldDecentralized.lf). The pattern is:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">reaction(in) {=\n    // User code\n=} tardy {=\n    // Error handling code\n=}</code></pre></div>\n<p>If the timestamp at which this reaction is to be invoked (the value returned by <code class=\"language-text\">get_current_tag</code>) cannot match the timestamp of an incoming message <code class=\"language-text\">in</code> (because the current tag has already advanced beyond the intended tag of <code class=\"language-text\">in</code>), then the <code class=\"language-text\">tardy</code> handler will be invoked instead of the normal reaction. Within the body of the tardy handler, the code can access the intended tag of <code class=\"language-text\">in</code> using <code class=\"language-text\">in->intended_tag</code>, which has two fields, a timestamp <code class=\"language-text\">in->intended_tag.time</code> and a microstep <code class=\"language-text\">in->intended_tag.microstep</code>. The code can then ascertain the severity of the error and act accordingly. If no tardy handler is provided at any reaction triggered by an input from another federate, then the normal reaction will be invoked at the earliest feasible logical time greater than or equal to the intended logical time of the message.</p>\n<p>One option available to the code is to increase the STP. This can be done simply by equipping a federate with a parameter of type <strong>time</strong> named <code class=\"language-text\">STP</code>. See for example <a href=\"https://github.com/lf-lang/lingua-franca/blob/master/example/C/Federated/HelloWorld/HelloWorldDecentralizedSTP.lf\">example/C/Federated/HelloWorld/HelloWorldDecentralizedSTP.lf</a>. This can be done as follows:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import PrintMessageWithDetector from \"HelloWorldDecentralized.lf\"\nreactor PrintMessageWithSTP(STP:time(10 msec)) extends PrintMessageWithDetector {}</code></pre></div>\n<p>Notice that the only override in <code class=\"language-text\">PrintMessageWithSTP</code> is the addition of an <code class=\"language-text\">STP</code> parameter.</p>\n<p>The LF API provides two functions that can be used to dynamically adjust the STP:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">interval_t get_stp_offset();\nvoid set_stp_offset(interval_t offset);</code></pre></div>\n<p>Using these functions, however, is a pretty advanced operation.</p>\n<p><strong>FIXME:</strong> The discussion of cycles in the remainder of this section needs to be revisited with pointers to newer examples.</p>\n<p>Now suppose that if there are cycles in the communication between federates. For example, in addition to the above connection, suppose we also have a connection going in the opposite direction:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">\tprint.out -> count.in after 100 msec;</code></pre></div>\n<p>Now we potentially have a very big problem. The physical clock at <code class=\"language-text\">print</code> has to lag behind physical time by at least <em>E</em> + <em>L</em> - 200 msec, and the physical clock at <code class=\"language-text\">count</code> has to lag behind physical time by at least <em>E</em> + <em>L</em> - 100 msec. The latter of these means that <code class=\"language-text\">count</code> cannot send a message with timestamp <em>t</em> until its local clock exceeds <em>t</em> + <em>E</em> + <em>L</em> - 100 msec. If <em>E</em> + <em>L</em> - 100 msec > 0, then this additional lag increases the required lag at <code class=\"language-text\">print</code>, which will need to lag behind physical time now by <em>E</em> + <em>L</em> - 100 msec + <em>E</em> + <em>L</em> - 200 msec. If this number is positive, then the lag required at <code class=\"language-text\">count</code> will have to be again increased, which will then cause this number to again increase, and so on until the required lag is infinite at both federates. Thus, a cycle between two federates is <strong>infeasible</strong> if 2<em>E</em> + 2<em>L</em> - <em>a</em><sub>1</sub> - <em>a</em><sub>2</sub> > 0, where <em>a</em><sub>1</sub> and <em>a</em><sub>2</sub> are the <strong>after</strong> values of the two connections. More generally, the sum of <em>E</em> + <em>L</em> - <em>a</em><sub>i</sub> over all connections <em>i</em> in a cycle must be less than or equal to zero. Otherwise, decentralized coordination will fail and finite STP will lead to tardy messages. Centralized coordination can be used instead if the program really must be this way.</p>\n<p>The bottom line is that if there are cycles in your federation and/or you have physical actions in federates that receive network messages, it is wise to specify <strong>after</strong> to be larger than the sum of the greatest expect clock synchronization error <em>E</em> and the greatest expected network latency <em>L</em>.</p>\n<h2 id=\"physical-connections\" style=\"position:relative;\"><a href=\"#physical-connections\" aria-label=\"physical connections permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Physical Connections</h2>\n<p>Coordinating the execution of the federates so that timestamps are preserved is tricky. If your application does not require the deterministic execution that results from preserving the timestamps, then you can alternatively specify a <strong>physical connection</strong> as follows (see <a href=\"https://github.com/lf-lang/lingua-franca/blob/master/example/C/Federated/HelloWorld/HelloWorldPhysical.lf\">example/C/Federated/HelloWorld/HelloWorldPhysical.lf</a>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">source.out ~> print.in;</code></pre></div>\n<p>The tilde specifies that the timestamp of the sender should be discarded. A new timestamp will be assigned at the receiving end based on the local physical clock, much like a <strong>physical action</strong>. To distinguish it from a physical connection, the normal connection is called a <strong>logical connection</strong>.</p>\n<p>There are a number of subtleties with physical connections. One is that if you specify an <code class=\"language-text\">after</code> clause, for example like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">count.out ~> print.in after 10 msec;</code></pre></div>\n<p>then what does this mean? At the receiving end, the timestamp assigned to the incoming event will be the current physical time plus 10 msec.</p>\n<h2 id=\"prerequisites-for-distributed-execution\" style=\"position:relative;\"><a href=\"#prerequisites-for-distributed-execution\" aria-label=\"prerequisites for distributed execution permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Prerequisites for Distributed Execution</h2>\n<p>In the above example, all of the generated programs expect to run on localhost. This is the default. With these defaults, every federate has to run on the same machine as the RTI because localhost is not a host that is visible from other machines on the network. In order to run federates or the RTI on remote machines, you can specify a domain name or IP address for the RTI and/or federates.</p>\n<p>In order for a federated execution to work, there is some setup required on the machines to be used. First, each machine must be running on <code class=\"language-text\">ssh</code> server. On a Linux machine, this is typically done with a command like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    sudo systemctl &lt;start|enable> ssh.service</code></pre></div>\n<p>Enable means to always start the service at startup, whereas start means to just start it this once. On MacOS, open System Preferences from the Apple menu and click on the “Sharing” preference panel. Select the checkbox next to “Remote Login” to enable it. <strong>FIXME</strong>: Windows?</p>\n<p>It will also be much more convenient if the launcher does not have to enter passwords to gain access to the remote machine. This can be accomplished by installing your public key (typically found in <code class=\"language-text\">~/.ssh/id_rsa.pub</code>) in <code class=\"language-text\">~/.ssh/authorized_keys</code> on the remote host.</p>\n<p>Second, the RTI must be installed on the remote machine. Instructions about installation of RTI can be found <a href=\"https://github.com/lf-lang/lingua-franca/blob/master/org.lflang/src/lib/core/federated/RTI/README.md\">here</a>.</p>\n<h2 id=\"specifying-rti-hosts\" style=\"position:relative;\"><a href=\"#specifying-rti-hosts\" aria-label=\"specifying rti hosts permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Specifying RTI Hosts</h2>\n<p>You can specify a domain name on which the RTI should run as follows:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">federated reactor DistributedCount at www.example.com {\n    ...\n}</code></pre></div>\n<p>You can alternatively specify an IP address (either IPv4 or IPv6):</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">federated reactor DistributedCount at 10.0.0.198 { ... }</code></pre></div>\n<p>By default, the RTI starts a socket server on port 15045, if that port is available, and increments the port number by 1 until it finds an available port. The number of increments is limited by a target-specific number. In the C target, in rti.h, STARTING_PORT defines the number 15045 and PORT_RANGE_LIMIT limits the range of ports attempted (currently 1024).</p>\n<p>You can also specify a port for the RTI to use as follows:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">federated reactor DistributedCount at 10.0.0.198:8080 { ... }</code></pre></div>\n<p>If you specify a specific port, then it will use that port if it is available and fail otherwise. The above changes this to port 8080.</p>\n<p>You can also specify a user name on the remote machine for cases where the username will not match whoever launches the federation:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">federated reactor DistributedCount at user@10.0.0.198:8080 { ... }</code></pre></div>\n<p>The general form of the host designation is</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">federated reactor DistributedCount at user@host:port/path { ... }</code></pre></div>\n<p>where <code class=\"language-text\">user@</code>, <code class=\"language-text\">:port</code>, and <code class=\"language-text\">/path</code> are all optional. The <code class=\"language-text\">path</code> specifies the directory on the remote machine (relative to the home directory of the user) where the generated code will be put. The <code class=\"language-text\">host</code> should be an IPv4 address (e.g. <code class=\"language-text\">93.184.216.34</code>), IPv6 address (e.g. <code class=\"language-text\">2606:2800:220:1:248:1893:25c8:1946</code>), or a domain name (e.g. <code class=\"language-text\">www.example.com</code>). It can also be <code class=\"language-text\">localhost</code> or <code class=\"language-text\">0.0.0.0</code>. The host can be remote as long as it is accessible from the machine where the programs will be started.</p>\n<p>If <code class=\"language-text\">user@</code> is not given, then it is assumed that the username on the remote host is the same as on the machine that launches the programs. If <code class=\"language-text\">:port</code> is not given, then it defaults to port 15045. If <code class=\"language-text\">/path</code> is not given, then <code class=\"language-text\">~user/LinguaFrancaRemote</code> will be the root directory on the remote machine.</p>\n<p><strong>FIXME</strong>: Not implemented yet: If the IP address or hostname does not match the local machine on which code generation is being done, …</p>\n<p>A <code class=\"language-text\">Federation_distribute.sh</code> shell script will be generated. This script will distribute the generated code for the RTI to the remote machine at the specified directory.</p>\n<h2 id=\"specifying-federate-hosts\" style=\"position:relative;\"><a href=\"#specifying-federate-hosts\" aria-label=\"specifying federate hosts permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Specifying Federate Hosts</h2>\n<p>A federate may be mapped to a particular remote machine using a syntax like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    count = new Count() at user@host:port/path;</code></pre></div>\n<p>The <code class=\"language-text\">port</code> is ignored in <strong>centralized</strong> mode because all communication is routed through the RTI, but in <strong>decentralized</strong> mode it will specify the port on which a socket server listens for incomming connections from other federates.</p>\n<p>If any federate (or the RTI) has such a remote designator, then a <code class=\"language-text\">Federation_distribute.sh</code> shell script will be generated. This script will distribute the generated code for the RTI to the remote machine at the specified directory.</p>\n<p>Note that if the machine uses DHCP to obtain its address, then the generated code may not work in the future since the address of the machine may change in the future.</p>\n<p>Address 0.0.0.0: In the above example, <code class=\"language-text\">localhost</code> is used. This is the default if no address is specified. Using <code class=\"language-text\">localhost</code> specifies that the generated programs should establish connections only with processes running on the local machine. This is ideal for testing. If you use <code class=\"language-text\">0.0.0.0</code>, then you are also specifying that the local machine (the one performing the code generation) will be the host, but now the process(es) running on this local machine can establish connections with processes on remote machines. The code generator will determine the IP address of the local machine, and any other hosts that need to communicate with reactors on the local host will use the current IP address of that local host at the time of code generation.</p>\n<h2 id=\"clock-synchronization\" style=\"position:relative;\"><a href=\"#clock-synchronization\" aria-label=\"clock synchronization permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Clock Synchronization</h2>\n<p>Both centralized and decentralized coordination have some reliance on clock synchronization. First, the RTI determines the start time of all federates, and the actually physical start time will differ by the extent that their physical clocks differ. This is particularly problematic if clocks differ by hours or more, which is certainly possible. If the hosts on which you are running run a clock synchronization algorithm, such as <a href=\"https://en.wikipedia.org/wiki/Network_Time_Protocol\">NTP</a> or <a href=\"https://en.wikipedia.org/wiki/Precision_Time_Protocol\">PTP</a>, then you may not need to be concerned about this at all. Windows, Mac, and most versions of Linux, by default, run NTP, which synchronizes their clocks to some remote host. NTP is not particularly precise, however, so clock synchronization error can be hundreds of milliseconds or larger. PTP protocols are much more precise, so if your hosts derive their physical clocks from a PTP implementation, then you probably don’t need to do anything further. Unfortunately, as of this writing, even though almost all networking hardware provides support for PTP, few operating systems utilize it. We expect this to change when people have finally understood the value of precise clock synchronization.</p>\n<p>If your host is not running any clock synchronization, or if it is running only NTP and your application needs tighter latencies, then Lingua Franca’s own built-in clock synchronization may provide better precision, depending on your network conditions. Like NTP, it realizes a software-only protocol, which are much less precise than hardware-supported protocols such as PTP, but if your hosts are on the same local area network, then network conditions may be such that the performance of LF clock synchronization will be much better than NTP. If your network is equipped with PTP, you will want to disable the clock synchronization in Lingua Franca by specifying in your target properties the following:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    clock-sync: off</code></pre></div>\n<p>When a federation is mapped onto multiple machines, then, by default, any federate mapped to a machine that is not the one running the RTI will attempt during startup to synchronize its clock with the one on the machine running the RTI. The determination of whether the federate is running on the same machine is determined by comparing the string that comes after the <code class=\"language-text\">at</code> clause between the federate and the RTI. If they differ at all, then they will be treated as if the federate is running on a different machine even if it is actually running on the same machine. This default behavior can be obtained by either specifying nothing in the target properties or saying:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    clock-sync: initial</code></pre></div>\n<p>This results in clock synchronization being done during startup only. To account for the possibility of your clocks drifting during execution of the program, you can alternatively specify:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    clock-sync: on</code></pre></div>\n<p>With this specification, in addition to synchronization during startup, synchronization will be redone periodically during program execution.</p>\n<h3 id=\"clock-synchronization-options\" style=\"position:relative;\"><a href=\"#clock-synchronization-options\" aria-label=\"clock synchronization options permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Clock Synchronization Options</h3>\n<p>A number of options can be specified using the <code class=\"language-text\">clock-sync-options</code> target parameter. For example:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    clock-sync-options: {local-federates-on: true, test-offset: 200 msec}</code></pre></div>\n<p>The supported options are:</p>\n<ul>\n<li>\n<p><code class=\"language-text\">local-federates-on</code>: Should be <code class=\"language-text\">true</code> or <code class=\"language-text\">false</code>. By default, if a federate is mapped to the same host as the RTI (using the <code class=\"language-text\">at</code> keyword), then clock synchronization is turned off. This assumes that the federate will be using the same clock as the RTI, so there is no point in performing clock synchronization. However, sometimes it is useful to force clock synchronization to be run even in this case, for example to test the performance of clock synchronization. To force clock synchronization on in this case, set this option to <code class=\"language-text\">true</code>.</p>\n</li>\n<li>\n<p><code class=\"language-text\">test-offset</code>: The value should be a time value with units, e.g. <code class=\"language-text\">200 msec</code>. This will establish an artificial fixed offset for each federate’s clock of one plus the federate ID times the time value given. For example, with the value <code class=\"language-text\">200 msec</code>, a fixed offset of 200 milliseconds will be set on the clock for federate 0, 400 msec on the clock of federate 1, etc.</p>\n</li>\n<li>\n<p><code class=\"language-text\">period</code>: A time value (with units) that specifies how often runtime clock synchronization will be performed if it is turned on. The default is <code class=\"language-text\">5 msec</code>.</p>\n</li>\n<li>\n<p><code class=\"language-text\">attenuation</code>: A positive integer specifying a divisor applied to the estimated clock error during runtime clock synchronization when adjusting the clock offset. The default is <code class=\"language-text\">10</code>. Making this number bigger reduces each adjustment to the clock. Making the number equal to <code class=\"language-text\">1</code> means that each round of clock synchronization fully applies its estimated clock synchronization error.</p>\n</li>\n<li>\n<p><code class=\"language-text\">trials</code>: The number of rounds of message exchange with the RTI in each clock synchronization round. This defaults to <code class=\"language-text\">10</code>.</p>\n</li>\n</ul>\n<h2 id=\"future-work\" style=\"position:relative;\"><a href=\"#future-work\" aria-label=\"future work permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Future Work</h2>\n<p>The RTI can also play the role of <strong>auth</strong>, an authentication and authorization server that ensures that only the generated programs can establish connections with each other and that their communication is encrypted, as explained in the <a href=\"#Security\">Security</a> section below.</p>\n<p>Currently, the threads option is same on all federates. We need a mechanism to customize this parameter by federate.</p>\n<h2 id=\"security\" style=\"position:relative;\"><a href=\"#security\" aria-label=\"security permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Security</h2>\n<p>In addition to generating a program for each host, the code generator could generate configuration files for a program called <strong>auth</strong> designed to run on the first host that is preconfigured to provide authentication and authorization to each of the other generated programs together with encryption keys that are used for communicating between them. The auth program should be started first since non of the other generate programs will be able to authenticate without it.</p>\n<p>The auth program, written by Hokeun Kim, comes from <a href=\"https://github.com/iotauth/iotauth\">https://github.com/iotauth/iotauth</a> and provides “locally centralized, globally distributed” authentication and authorization. Papers describing this work can be found here: [<a href=\"https://dl.acm.org/citation.cfm?id=3054980\">IoTDI ‘17</a>], [<a href=\"http://ieeexplore.ieee.org/document/7575852/\">FiCloud ‘16</a>] [<a href=\"https://ieeexplore.ieee.org/document/8057722/\">IT Professional ‘17’</a>].</p>\n<h2 id=\"protobufs\" style=\"position:relative;\"><a href=\"#protobufs\" aria-label=\"protobufs permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Protobufs</h2>\n<p>Communication between hosts can only be accomplished on channels where the message types are either language primitives or <a href=\"Protobufs\">Protobufs</a>. All other datatypes will be reject at code generation time.</p>\n</div>","headings":[{"value":"Minimal Example","depth":2},{"value":"Coordinated Start","depth":2},{"value":"Coordinated Shutdown","depth":2},{"value":"Communication Between Federates","depth":2},{"value":"Containerized Execution","depth":2},{"value":"Centralized Coordination","depth":2},{"value":"Decentralized Coordination","depth":2},{"value":"Physical Connections","depth":2},{"value":"Prerequisites for Distributed Execution","depth":2},{"value":"Specifying RTI Hosts","depth":2},{"value":"Specifying Federate Hosts","depth":2},{"value":"Clock Synchronization","depth":2},{"value":"Clock Synchronization Options","depth":3},{"value":"Future Work","depth":2},{"value":"Security","depth":2},{"value":"Protobufs","depth":2}],"frontmatter":{"permalink":"/docs/handbook/distributed-execution","title":"Distributed Execution","oneline":"Distributed Execution (preliminary)","preamble":""}},"prev":{"childMarkdownRemark":{"frontmatter":{"title":"Preambles and Methods","oneline":"Defining functions and methods in Lingua Franca.","permalink":"/docs/handbook/preambles-and-methods"}}},"next":{"childMarkdownRemark":{"frontmatter":{"title":"Termination","oneline":"Terminating a Lingua Franca execution.","permalink":"/docs/handbook/termination"}}}},"pageContext":{"id":"1-distributed-execution","slug":"/docs/handbook/distributed-execution","repoPath":"/packages/documentation/copy/en/topics/Distributed Execution.md","previousID":"ad997ea4-968f-5012-ae5e-dd662a50d4b7","nextID":"2f20b3c3-82ed-5e2c-9a7a-eca75b12a227","lang":"en","modifiedTime":"2022-04-28T02:31:46.690Z"}},
    "staticQueryHashes": []}